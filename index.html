<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Игра "Жизнь"</title>
  <style>
    /* Ваш стиль остается без изменений */
  </style>
</head>
<body>
  <div class="grid" id="grid"></div>
  <input type="color" id="colorPicker" value="#333" onchange="changeColor()">
  <button onclick="startGame()">Старт</button>
  <button onclick="stopGame()">Стоп</button>
  <button onclick="clearGrid()">Очистить</button>
  <!-- Добавлены кнопки для режимов и их обработчики событий -->
  <button onclick="enableCaptureMode()">Режим захвата</button>
  <button onclick="enableReproductionMode()">Режим размножения</button>
  <script>
    const rows = 20;
    const cols = 20;
    let grid = createEmptyGrid();
    let intervalId;
    let isDrawing = false;
    let isCaptureMode = false;
    let isReproductionMode = false;
    let currentColor = '#333';

    function createEmptyGrid() {
      return Array.from({ length: rows }, () => Array(cols).fill(false));
    }

    function renderGrid() {
      const gridContainer = document.getElementById('grid');
      gridContainer.innerHTML = '';

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const cellElement = document.createElement('div');
          cellElement.classList.add('cell', grid[row][col] ? 'alive' : 'dead');
          cellElement.addEventListener('mousedown', (event) => handleMouseDown(event, row, col));
          cellElement.addEventListener('mousemove', (event) => handleMouseMove(event, row, col));
          cellElement.addEventListener('mouseup', handleMouseUp);
          gridContainer.appendChild(cellElement);
        }
      }
    }
    
    function renderCell(row, col) {
      const cellIndex = row * cols + col;
      const cellElement = document.querySelector(`.grid .cell:nth-child(${cellIndex + 1})`);
      cellElement.classList.toggle('alive', grid[row][col]);
      cellElement.classList.toggle('dead', !grid[row][col]);
    }

    function handleMouseDown(event, row, col) {
      isDrawing = true;
      toggleCell(row, col);
    }

    function handleMouseMove(event, row, col) {
      if (isDrawing) {
        toggleCell(row, col);
      }
    }

    function handleMouseUp() {
      isDrawing = false;
    }

    function toggleCell(row, col) {
      if (row >= 0 && row < rows && col >= 0 && col < cols) {
        if (isCaptureMode) {
          captureColor(row, col);
        } else if (isReproductionMode) {
          reproduceColor(row, col);
        } else {
          grid[row][col] = !grid[row][col];
        }
        renderCell(row, col);
      }
    }

    function captureColor(row, col) {
      const targetColor = grid[row][col] ? '#fff' : currentColor;
      fillConnectedCells(row, col, targetColor);
    }

    function reproduceColor(row, col) {
      const neighborColors = getNeighborColors(row, col);
      const newColor = mixColors(neighborColors);
      grid[row][col] = true;
      fillConnectedCells(row, col, newColor);
    }

    function fillConnectedCells(row, col, color) {
      // Реализуйте заполнение связанных клеток с определенным цветом
      // Например, используя алгоритм заливки (flood fill)
    }

    function getNeighborColors(row, col) {
      // Получите цвета соседей клетки
      // Верните массив цветов
    }

    function mixColors(colors) {
      // Реализуйте логику смешивания цветов, чтобы получить новый цвет
      // Например, просто верните средний цвет из массива colors
    }

    function enableCaptureMode() {
      isCaptureMode = true;
      isReproductionMode = false;
    }

    function enableReproductionMode() {
      isCaptureMode = false;
      isReproductionMode = true;
    }

    function startGame() {
      intervalId = setInterval(updateGrid, 500);
    }

    function stopGame() {
      clearInterval(intervalId);
    }

    function clearGrid() {
      grid = createEmptyGrid();
      renderGrid();
    }

    function updateGrid() {
      const newGrid = createEmptyGrid();

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const neighbors = countNeighbors(row, col);
          const isAlive = grid[row][col];

          if (isAlive && (neighbors < 2 || neighbors > 3)) {
            newGrid[row][col] = false;
          } else if (!isAlive && neighbors === 3) {
            newGrid[row][col] = true;
          } else {
            newGrid[row][col] = isAlive;
          }
        }
      }

      grid = newGrid;
      renderGrid();
    }

    function countNeighbors(row, col) {
      let count = 0;

      for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
          const neighborRow = row + i;
          const neighborCol = col + j;

          if (neighborRow >= 0 && neighborRow < rows && neighborCol >= 0 && neighborCol < cols) {
            count += grid[neighborRow][neighborCol] ? 1 : 0;
          }
        }
      }

      count -= grid[row][col] ? 1 : 0;

      return count;
    }

    function changeColor() {
      const colorPicker = document.getElementById('colorPicker');
      currentColor = colorPicker.value;
    }

    renderGrid();
  </script>
</body>
</html>